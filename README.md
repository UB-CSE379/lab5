## Lab #5
Spring 2024
# Objective
In this lab, you will learn how to service interrupts on the ARM processor.
Description
Write interrupt initialization and handler routines to process two interrupts. The first interrupts the
processor when the user hits a key on the keyboard. The initialization routine for this interrupt should be
called uart_interrupt_init, and it should generate an interrupt when a keystroke is generated by the user in
PuTTy (UART0). The interrupt handler associated with this interrupt is UART0_Handler. The second
interrupts the processor when the button labeled SW1 on the Tiva board is pressed. The initialization
routine for this interrupt should be called gpio_interrupt_init, and it should generate an interrupt when a
SW1 on the Tiva board is pressed. The interrupt handler associated with this interrupt is
Switch_Handler. In both handlers the interrupt should be cleared at the beginning of the routine, and
control transferred back to your program after the interrupt is processed.
Your main program (lab5 routine) should implement a reflex game that allows two players to compete to
see who has faster reflexes. One player uses SW1 on the Tiva and the other uses the space bar on the
keyboard. The game should present directions for the game to the user, then have them hit the Enter key
on the keyboard when they are ready to play and start the first round. Each round starts by hitting the
Enter key. After a small random amount of time (which can be implemented by a loop), they should be
prompted to press their respective button (SW1 or the space bar). The first one to do so gets a point for
that round. If they pressed their button too early (before the prompt), then they are disqualified from that
round and don’t earn a point. If both players press their buttons too early, neither player gets a point for
that round. At the end of each round, the prompt informing them to press a key should be erased, the
scores for each player should be displayed, and the players should be instructed to press the Enter key to
start the next round. Players continue playing until one player reaches three points and wins, at which
point the game ends.
You might find three ASCII characters of particular interest to help you implement the game. Carriage
return (ASCII value 13) moves the cursor to the beginning of the current line. This is useful if you’d like
to overwrite a line on the display. Line feed (ASCII value 10) moves the cursor down one line (but not to
the beginning of the line). Form feed (ASCII value 12) clears the screen.
Polling may NOT be used to obtain data from the keyboard or the push button. The data must be
obtained through the use of interrupts. When your lab is graded, a breakpoint will be set in each handler
to verify that interrupts are working properly and that the handler is processing the button press and
keypress.
Startup Code
Use the startup code on the Labs page of the course website, NOT the startup assembly file that you’ve
been including in your project when you create a project in past labs.
PreLab Flowchart
A flowchart of your main program and for each handler is required to be submitted or shown to the TA in
your regularly scheduled lab session before you start working on the lab in the UB Commons 113 Suite
during your regularly scheduled lab time.
Skeleton Code
The following skeleton code shown below can be used for lab_5.s.
.data
.global prompt
.global mydata
prompt: .string "Your prompt with instructions is place here", 0
mydata: .byte 0x20 ; This is where you can store data.
; The .byte assembler directive stores a byte
; (initialized to 0x20) at the label mydata.
; Halfwords & Words can be stored using the
; directives .half & .word
.text
.global uart_interrupt_init
.global gpio_interrupt_init
.global UART0_Handler
.global Switch_Handler
.global Timer_Handler ; This is needed for Lab #6
.global simple_read_character
.global output_character ; This is from your Lab #4 Library
.global read_string ; This is from your Lab #4 Library
.global output_string ; This is from your Lab #4 Library
.global uart_init ; This is from your Lab #4 Library
.global lab5
ptr_to_prompt: .word prompt
ptr_to_mydata: .word mydata
lab5: ; This is your main routine which is called from
; your C wrapper.
PUSH {r4-r12,lr} ; Preserve registers to adhere to the AAPCS
ldr r4, ptr_to_prompt
ldr r5, ptr_to_mydata
bl uart_init
bl uart_interrupt_init
bl gpio_interrupt_init
; This is where you should implement a loop, waiting for the user to
; enter a q, indicating they want to end the program.
POP {lr} ; Restore registers to adhere to the AAPCS
MOV pc, lr
uart_interrupt_init:
; Your code to initialize the UART0 interrupt goes here
MOV pc, lr
gpio_interrupt_init:
; Your code to initialize the SW1 interrupt goes here
; Don't forget to follow the procedure you followed in Lab #4
; to initialize SW1.
MOV pc, lr
UART0_Handler:
; Your code for your UART handler goes here.
; Remember to preserver registers r4-r11 by pushing then popping
; them to & from the stack at the beginning & end of the handler
BX lr ; Return
Switch_Handler:
; Your code for your UART handler goes here.
; Remember to preserver registers r4-r11 by pushing then popping
; them to & from the stack at the beginning & end of the handler
BX lr ; Return
Timer_Handler:
; Your code for your Timer handler goes here. It is not needed for
; Lab #5, but will be used in Lab #6. It is referenced here because
; the interrupt enabled startup code has declared Timer_Handler.
; This will allow you to not have to redownload startup code for
; Lab #6. Instead, you can use the same startup code as for Lab #5.
; Remember to preserver registers r4-r11 by pushing then popping
; them to & from the stack at the beginning & end of the handler.
BX lr ; Return
simple_read_character:
MOV pc, lr ; Return
.end
Partners
You will work with a partner in this lab. You will be instructed in your regularly scheduled lab session or
via e-mail if your partner will be the same as the one you worked with on Lab #4 unless instructed to do
otherwise by the CSE 379 staff.
Documentation
Your program must be clearly commented, and documentation must also be provided. The
documentation must follow the guidelines covered in lecture (found on the Lectures webpage of the
course website). Your comments should describe what each section of your program does. To receive
full credit on your documentation, you must submit a draft of your flowchart before you start working on
the lab in your regularly scheduled lab time.
Submissions
Your source code (C and assembly) and your documentation (as a PDF) must be submitted online using
the submit command (submit_cse379 lab_5_wrapper.c lab_5.s lab_5_library.s lab_5_documentation.pdf)
on timberlake.cse.buffalo.edu before 11:59 PM on Sunday, March 10, 2024. 
